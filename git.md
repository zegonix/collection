# summary on some steps in the git workflow

## Table of contents

- [glossary](#glossary)
- [terminology](#terminology)
- [branches](#branches)
  - [create a branch](#create-a-branch)
- [submodules](#submodules)
- [removing files from index](#removing-files-from-index)
- [philosophies](#philosophies)
  - [merge](#merge)
  - [rebase](#rebase)

## terminology

| term | description |
| :--- | :---------- |
| `^` | one commit back (in history), use `<HEAD/branch/commit_hash>^` |
| head | pointer to branch (usually latest commit, unless detached=pointer to specific commit) currently checked out locally |
| index | keeps track of `staged/cached` (with git add) changes |
| working tree | local file working directory |


## branches

### create a branch

To create a branch use subcommand `branch` or `checkout` with flag `-b`:
```bash
# create new branch ('base-branch' is optional)
git branch <branch-name> <base-branch>
git checkout -b <branch-name> <base-branch>

# switch branch ('checkout -b' combines the 'branch' and 'switch' subcommands)
git switch <branch-name>
```


## submodules

To fetch submodules of a cloned repository use:
```sh
# do it manually
git submodule init
git submodule update

# do it all at once
git clone --recurse-submodules

# if repo is already cloned
git submodule update --init --recursive
```


## removing files from index

To remove files from index without deleting them on disk, use:
```sh
git rm --cached <file-name>
```
This is helpful if one accidentally committed autogenerated files.


## philosophies

Important things to always remember:
**- do renaming in seperate commit**
**- don't merge conflicts with directories**


### merge

When following the philosophie of merging, one merges the target branch into ones working, solves all conflicts, tests the result and then merges the working branch into the target branch. This is done with
```sh
# merges 'target-branch' into curret branch
git merge <target-branch>

# proceeds after solving merge conflict
git merge --continue
```


### rebase

When following the philosophie of rebasing, one rebases the feature branch onto the target branch. This is done with
```sh
# rebases current branch onto 'target-branch'
git rebase <target-branch>

# proceeds after solving rebase conflict
git rebase --continue
```
This is only necessary, if the 'main' branch progressed in the mean time, otherwise one just merges the feature branch into the 'main' branch.

